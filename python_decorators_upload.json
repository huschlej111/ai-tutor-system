{
  "domains": [
    {
      "node_type": "domain",
      "data": {
        "name": "Python Built-in Decorators",
        "description": "Essential decorators that are part of Python's standard library for enhancing class and function behavior",
        "subject": "python",
        "difficulty": "intermediate",
        "estimated_hours": 8,
        "prerequisites": [
          "Python functions",
          "Object-oriented programming"
        ]
      },
      "metadata": {
        "version": 1,
        "tags": [
          "python",
          "decorators",
          "built-in",
          "standard-library"
        ]
      },
      "terms": [
        {
          "node_type": "term",
          "data": {
            "term": "@property",
            "definition": "The @property decorator transforms a method of a class into a 'getter' for a property of the same name. This allows you to access the method as if it were an attribute. It can be combined with @<property_name>.setter and @<property_name>.deleter to control the modification and deletion of the attribute, respectively.",
            "difficulty": "intermediate",
            "module": "built-in",
            "examples": [
              "Creating read-only attributes",
              "Computed properties with validation",
              "Getter/setter/deleter patterns"
            ],
            "code_example": "class Circle:\n    def __init__(self, radius):\n        self._radius = radius\n\n    @property\n    def radius(self):\n        \"\"\"The radius property.\"\"\"\n        print(\"Getting radius\")\n        return self._radius\n\n    @radius.setter\n    def radius(self, value):\n        if value <= 0:\n            raise ValueError(\"Radius must be positive\")\n        print(f\"Setting radius to {value}\")\n        self._radius = value\n\n    @radius.deleter\n    def radius(self):\n        print(\"Deleting radius\")\n        del self._radius\n\n# Usage\ncircle = Circle(10)\nprint(f\"The radius is: {circle.radius}\")\ncircle.radius = 12\nprint(f\"The new radius is: {circle.radius}\")\ndel circle.radius"
          },
          "metadata": {
            "keywords": [
              "property",
              "getter",
              "setter",
              "deleter",
              "attribute"
            ],
            "related_concepts": [
              "@staticmethod",
              "@classmethod"
            ]
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "@staticmethod",
            "definition": "The @staticmethod decorator defines a static method within a class. A static method does not receive an implicit first argument (neither `self` for an instance nor `cls` for the class). It is essentially a regular function namespaced within the class and cannot modify the object's or class's state.",
            "difficulty": "beginner",
            "module": "built-in",
            "examples": [
              "Utility functions within classes",
              "Mathematical operations",
              "Helper methods that don't need instance data"
            ],
            "code_example": "class MathOperations:\n    @staticmethod\n    def add(x, y):\n        return x + y\n\n    @staticmethod\n    def multiply(x, y):\n        return x * y\n\n# Usage\nsum_result = MathOperations.add(5, 3)\nproduct_result = MathOperations.multiply(5, 3)\nprint(f\"Sum: {sum_result}\")\nprint(f\"Product: {product_result}\")"
          },
          "metadata": {
            "keywords": [
              "static",
              "method",
              "utility",
              "namespace"
            ],
            "related_concepts": [
              "@classmethod",
              "@property"
            ]
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "@classmethod",
            "definition": "The @classmethod decorator defines a method that receives the class as its first argument, conventionally named `cls`, rather than the instance. It can be used to work with the class itself, such as creating factory methods that can instantiate the class in alternative ways.",
            "difficulty": "intermediate",
            "module": "built-in",
            "examples": [
              "Factory methods for alternative constructors",
              "Class-level operations",
              "Alternative initialization patterns"
            ],
            "code_example": "from datetime import date\n\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    @classmethod\n    def from_birth_year(cls, name, birth_year):\n        current_year = date.today().year\n        age = current_year - birth_year\n        return cls(name, age)\n\n# Usage\nperson1 = Person(\"Alice\", 30)\nperson2 = Person.from_birth_year(\"Bob\", 1995)\n\nprint(f\"{person1.name} is {person1.age} years old.\")\nprint(f\"{person2.name} is {person2.age} years old.\")"
          },
          "metadata": {
            "keywords": [
              "class",
              "method",
              "factory",
              "constructor",
              "cls"
            ],
            "related_concepts": [
              "@staticmethod",
              "@property"
            ]
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "@abstractmethod",
            "definition": "The @abstractmethod decorator is used to declare a method as abstract. A class containing one or more abstract methods becomes an abstract base class and cannot be instantiated. Subclasses must implement all inherited abstract methods to be instantiable.",
            "difficulty": "advanced",
            "module": "abc",
            "examples": [
              "Abstract base classes",
              "Interface definitions",
              "Template method patterns"
            ],
            "code_example": "from abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    @abstractmethod\n    def area(self):\n        pass\n\n    @abstractmethod\n    def perimeter(self):\n        pass\n\nclass Square(Shape):\n    def __init__(self, side):\n        self.side = side\n\n    def area(self):\n        return self.side * self.side\n\n    def perimeter(self):\n        return 4 * self.side\n\n# try:\n#     shape = Shape()  # This would raise a TypeError\n# except TypeError as e:\n#     print(e)\n\nsquare = Square(5)\nprint(f\"Area of the square: {square.area()}\")\nprint(f\"Perimeter of the square: {square.perimeter()}\")"
          },
          "metadata": {
            "keywords": [
              "abstract",
              "method",
              "abc",
              "interface",
              "inheritance"
            ],
            "related_concepts": [
              "inheritance",
              "polymorphism"
            ]
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "@atexit.register",
            "definition": "The @atexit.register decorator registers a function to be executed when the Python interpreter exits. These functions are called in the reverse order of their registration.",
            "difficulty": "intermediate",
            "module": "atexit",
            "examples": [
              "Cleanup operations",
              "Resource deallocation",
              "Graceful shutdown procedures"
            ],
            "code_example": "import atexit\n\n@atexit.register\ndef cleanup():\n    print(\"Performing cleanup tasks...\")\n\nprint(\"Program is running.\")\n# When the script finishes, the cleanup function will be called."
          },
          "metadata": {
            "keywords": [
              "atexit",
              "cleanup",
              "exit",
              "shutdown"
            ],
            "related_concepts": [
              "context managers",
              "resource management"
            ]
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "@dataclass",
            "definition": "The @dataclass decorator automatically generates special methods such as `__init__()`, `__repr__()`, `__eq__()`, and others for user-defined classes. This reduces boilerplate code for classes that primarily store data.",
            "difficulty": "intermediate",
            "module": "dataclasses",
            "examples": [
              "Data containers with automatic methods",
              "Immutable data structures",
              "Configuration objects"
            ],
            "code_example": "from dataclasses import dataclass\n\n@dataclass\nclass Point:\n    x: float\n    y: float\n\n# Usage\np1 = Point(1.0, 2.0)\np2 = Point(1.0, 2.0)\n\nprint(p1)\nprint(p1 == p2)"
          },
          "metadata": {
            "keywords": [
              "dataclass",
              "data",
              "boilerplate",
              "automatic"
            ],
            "related_concepts": [
              "type hints",
              "classes"
            ]
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "@unique",
            "definition": "The @unique decorator for enumerations ensures that each value within the enumeration is distinct. If duplicate values are found, a `ValueError` is raised.",
            "difficulty": "intermediate",
            "module": "enum",
            "examples": [
              "Ensuring unique enum values",
              "Preventing duplicate constants",
              "Validation of enumeration definitions"
            ],
            "code_example": "from enum import Enum, unique\n\n@unique\nclass Color(Enum):\n    RED = 1\n    GREEN = 2\n    BLUE = 3\n    # CRIMSON = 1  # This would raise a ValueError\n\n# Usage\nprint(Color.RED)"
          },
          "metadata": {
            "keywords": [
              "unique",
              "enum",
              "enumeration",
              "validation"
            ],
            "related_concepts": [
              "enumerations",
              "constants"
            ]
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "@functools.wraps",
            "definition": "The @functools.wraps decorator is a helper for creating well-behaved decorators. It updates the wrapper function to look like the wrapped function by copying attributes such as `__name__`, `__doc__`, and the function's signature.",
            "difficulty": "advanced",
            "module": "functools",
            "examples": [
              "Creating custom decorators",
              "Preserving function metadata",
              "Decorator composition"
            ],
            "code_example": "import functools\nimport time\n\ndef timer(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        \"\"\"A wrapper function that times the execution.\"\"\"\n        start_time = time.perf_counter()\n        result = func(*args, **kwargs)\n        end_time = time.perf_counter()\n        print(f\"'{func.__name__}' ran in {end_time - start_time:.4f}s\")\n        return result\n    return wrapper\n\n@timer\ndef long_running_function():\n    \"\"\"This is a function that takes some time to run.\"\"\"\n    time.sleep(1)\n\nlong_running_function()\nprint(long_running_function.__name__)\nprint(long_running_function.__doc__)"
          },
          "metadata": {
            "keywords": [
              "functools",
              "wraps",
              "decorator",
              "metadata"
            ],
            "related_concepts": [
              "custom decorators",
              "function introspection"
            ]
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "@typing.overload",
            "definition": "The @typing.overload decorator allows you to define multiple signatures for the same function. This is useful for static type checkers to understand that a function can be called with different argument types, and it helps in providing more precise type information.",
            "difficulty": "advanced",
            "module": "typing",
            "examples": [
              "Function overloading for type checkers",
              "Multiple function signatures",
              "Static type analysis"
            ],
            "code_example": "from typing import overload, Union\n\n@overload\ndef process(data: str) -> str: ...\n@overload\ndef process(data: int) -> int: ...\n\ndef process(data: Union[str, int]) -> Union[str, int]:\n    if isinstance(data, str):\n        return data.upper()\n    elif isinstance(data, int):\n        return data * 2\n\n# Usage\nprint(process(\"hello\"))\nprint(process(10))"
          },
          "metadata": {
            "keywords": [
              "typing",
              "overload",
              "type hints",
              "static analysis"
            ],
            "related_concepts": [
              "type hints",
              "mypy",
              "static analysis"
            ]
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "@unittest.mock.patch",
            "definition": "The @unittest.mock.patch decorator is used to replace objects with `Mock` objects during tests. This allows for the isolation of the code under test from its dependencies. It can be used as a decorator or a context manager.",
            "difficulty": "advanced",
            "module": "unittest.mock",
            "examples": [
              "Mocking dependencies in tests",
              "Isolating code under test",
              "Test doubles and stubs"
            ],
            "code_example": "import unittest\nfrom unittest.mock import patch\nimport os\n\nclass MyTest(unittest.TestCase):\n    @patch('os.path.exists')\n    def test_path_exists(self, mock_exists):\n        # Configure the mock to return a specific value\n        mock_exists.return_value = True\n\n        # Call the code that uses os.path.exists\n        result = os.path.exists('/some/fake/path')\n\n        # Assert that the mock was called and the result is as expected\n        mock_exists.assert_called_with('/some/fake/path')\n        self.assertTrue(result)\n\nif __name__ == '__main__':\n    unittest.main(argv=['first-arg-is-ignored'], exit=False)"
          },
          "metadata": {
            "keywords": [
              "unittest",
              "mock",
              "patch",
              "testing",
              "isolation"
            ],
            "related_concepts": [
              "unit testing",
              "test doubles",
              "dependency injection"
            ]
          }
        }
      ]
    }
  ]
}