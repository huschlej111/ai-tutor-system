{
  "python_builtin_decorators": [
    {
      "decorator_name": "@property",
      "module": "built-in",
      "definition": "The @property decorator transforms a method of a class into a 'getter' for a property of the same name. This allows you to access the method as if it were an attribute. It can be combined with @<property_name>.setter and @<property_name>.deleter to control the modification and deletion of the attribute, respectively.",
      "code_example": "class Circle:\n    def __init__(self, radius):\n        self._radius = radius\n\n    @property\n    def radius(self):\n        \"\"\"The radius property.\"\"\"\n        print(\"Getting radius\")\n        return self._radius\n\n    @radius.setter\n    def radius(self, value):\n        if value <= 0:\n            raise ValueError(\"Radius must be positive\")\n        print(f\"Setting radius to {value}\")\n        self._radius = value\n\n    @radius.deleter\n    def radius(self):\n        print(\"Deleting radius\")\n        del self._radius\n\n# Usage\ncircle = Circle(10)\nprint(f\"The radius is: {circle.radius}\")\ncircle.radius = 12\nprint(f\"The new radius is: {circle.radius}\")\ndel circle.radius"
    },
    {
      "decorator_name": "@staticmethod",
      "module": "built-in",
      "definition": "The @staticmethod decorator defines a static method within a class. A static method does not receive an implicit first argument (neither `self` for an instance nor `cls` for the class). It is essentially a regular function namespaced within the class and cannot modify the object's or class's state.",
      "code_example": "class MathOperations:\n    @staticmethod\n    def add(x, y):\n        return x + y\n\n    @staticmethod\n    def multiply(x, y):\n        return x * y\n\n# Usage\nsum_result = MathOperations.add(5, 3)\nproduct_result = MathOperations.multiply(5, 3)\nprint(f\"Sum: {sum_result}\")\nprint(f\"Product: {product_result}\")"
    },
    {
      "decorator_name": "@classmethod",
      "module": "built-in",
      "definition": "The @classmethod decorator defines a method that receives the class as its first argument, conventionally named `cls`, rather than the instance. It can be used to work with the class itself, such as creating factory methods that can instantiate the class in alternative ways.",
      "code_example": "from datetime import date\n\nclass Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    @classmethod\n    def from_birth_year(cls, name, birth_year):\n        current_year = date.today().year\n        age = current_year - birth_year\n        return cls(name, age)\n\n# Usage\nperson1 = Person(\"Alice\", 30)\nperson2 = Person.from_birth_year(\"Bob\", 1995)\n\nprint(f\"{person1.name} is {person1.age} years old.\")\nprint(f\"{person2.name} is {person2.age} years old.\")"
    },
    {
      "decorator_name": "@abstractmethod",
      "module": "abc",
      "definition": "The @abstractmethod decorator is used to declare a method as abstract. A class containing one or more abstract methods becomes an abstract base class and cannot be instantiated. Subclasses must implement all inherited abstract methods to be instantiable.",
      "code_example": "from abc import ABC, abstractmethod\n\nclass Shape(ABC):\n    @abstractmethod\n    def area(self):\n        pass\n\n    @abstractmethod\n    def perimeter(self):\n        pass\n\nclass Square(Shape):\n    def __init__(self, side):\n        self.side = side\n\n    def area(self):\n        return self.side * self.side\n\n    def perimeter(self):\n        return 4 * self.side\n\n# try:\n#     shape = Shape()  # This would raise a TypeError\n# except TypeError as e:\n#     print(e)\n\nsquare = Square(5)\nprint(f\"Area of the square: {square.area()}\")\nprint(f\"Perimeter of the square: {square.perimeter()}\")"
    },
    {
      "decorator_name": "@atexit.register",
      "module": "atexit",
      "definition": "The @atexit.register decorator registers a function to be executed when the Python interpreter exits. These functions are called in the reverse order of their registration.",
      "code_example": "import atexit\n\n@atexit.register\ndef cleanup():\n    print(\"Performing cleanup tasks...\")\n\nprint(\"Program is running.\")\n# When the script finishes, the cleanup function will be called."
    },
    {
      "decorator_name": "@dataclass",
      "module": "dataclasses",
      "definition": "The @dataclass decorator automatically generates special methods such as `__init__()`, `__repr__()`, `__eq__()`, and others for user-defined classes. This reduces boilerplate code for classes that primarily store data.",
      "code_example": "from dataclasses import dataclass\n\n@dataclass\nclass Point:\n    x: float\n    y: float\n\n# Usage\np1 = Point(1.0, 2.0)\np2 = Point(1.0, 2.0)\n\nprint(p1)\nprint(p1 == p2)"
    },
    {
      "decorator_name": "@unique",
      "module": "enum",
      "definition": "The @unique decorator for enumerations ensures that each value within the enumeration is distinct. If duplicate values are found, a `ValueError` is raised.",
      "code_example": "from enum import Enum, unique\n\n@unique\nclass Color(Enum):\n    RED = 1\n    GREEN = 2\n    BLUE = 3\n    # CRIMSON = 1  # This would raise a ValueError\n\n# Usage\nprint(Color.RED)"
    },
    {
      "decorator_name": "@functools.wraps",
      "module": "functools",
      "definition": "The @functools.wraps decorator is a helper for creating well-behaved decorators. It updates the wrapper function to look like the wrapped function by copying attributes such as `__name__`, `__doc__`, and the function's signature.",
      "code_example": "import functools\nimport time\n\ndef timer(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        \"\"\"A wrapper function that times the execution.\"\"\"\n        start_time = time.perf_counter()\n        result = func(*args, **kwargs)\n        end_time = time.perf_counter()\n        print(f\"'{func.__name__}' ran in {end_time - start_time:.4f}s\")\n        return result\n    return wrapper\n\n@timer\ndef long_running_function():\n    \"\"\"This is a function that takes some time to run.\"\"\"\n    time.sleep(1)\n\nlong_running_function()\nprint(long_running_function.__name__)\nprint(long_running_function.__doc__)"
    },
    {
      "decorator_name": "@typing.overload",
      "module": "typing",
      "definition": "The @typing.overload decorator allows you to define multiple signatures for the same function. This is useful for static type checkers to understand that a function can be called with different argument types, and it helps in providing more precise type information.",
      "code_example": "from typing import overload, Union\n\n@overload\ndef process(data: str) -> str: ...\n@overload\ndef process(data: int) -> int: ...\n\ndef process(data: Union[str, int]) -> Union[str, int]:\n    if isinstance(data, str):\n        return data.upper()\n    elif isinstance(data, int):\n        return data * 2\n\n# Usage\nprint(process(\"hello\"))\nprint(process(10))"
    },
    {
      "decorator_name": "@unittest.mock.patch",
      "module": "unittest.mock",
      "definition": "The @unittest.mock.patch decorator is used to replace objects with `Mock` objects during tests. This allows for the isolation of the code under test from its dependencies. It can be used as a decorator or a context manager.",
      "code_example": "import unittest\nfrom unittest.mock import patch\nimport os\n\nclass MyTest(unittest.TestCase):\n    @patch('os.path.exists')\n    def test_path_exists(self, mock_exists):\n        # Configure the mock to return a specific value\n        mock_exists.return_value = True\n\n        # Call the code that uses os.path.exists\n        result = os.path.exists('/some/fake/path')\n\n        # Assert that the mock was called and the result is as expected\n        mock_exists.assert_called_with('/some/fake/path')\n        self.assertTrue(result)\n\nif __name__ == '__main__':\n    unittest.main(argv=['first-arg-is-ignored'], exit=False)"
    }
  ]
}