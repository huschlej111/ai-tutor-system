{
  "domains": [
    {
      "node_type": "domain",
      "data": {
        "name": "Python Built-in Functions",
        "description": "Comprehensive collection of Python's built-in functions that are always available without importing any module",
        "subject": "python",
        "difficulty": "intermediate",
        "estimated_hours": 20,
        "prerequisites": [
          "Python basics",
          "Functions"
        ]
      },
      "metadata": {
        "version": 1,
        "tags": [
          "python",
          "built-in",
          "functions",
          "standard-library"
        ],
        "source": "py_methods.json"
      },
      "terms": [
        {
          "node_type": "term",
          "data": {
            "term": "abs()",
            "definition": "Return the absolute value of a number.  The argument may be an\ninteger, a floating-point number, or an object implementing __abs__() .\nIf the argument is a complex number, its magnitude is returned.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "abs(x)"
          },
          "metadata": {
            "signature": "abs(x)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "aiter()",
            "definition": "Return an asynchronous iterator for an asynchronous iterable .\nEquivalent to calling x.__aiter__() .\n\nNote: Unlike iter() , aiter() has no 2-argument variant.\n\nAdded in version 3.10.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "aiter(async_iterable)"
          },
          "metadata": {
            "signature": "aiter(async_iterable)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "all()",
            "definition": "Return True if all elements of the iterable are true (or if the iterable\nis empty).  Equivalent to:",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "all(iterable)",
            "examples": [
              "defall(iterable):forelementiniterable:ifnotelement:returnFalsereturnTrue"
            ]
          },
          "metadata": {
            "signature": "all(iterable)",
            "has_examples": true
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "anext()",
            "definition": "When awaited, return the next item from the given asynchronous\niterator , or default if given and the iterator is exhausted.\n\nThis is the async variant of the next() builtin, and behaves\nsimilarly.\n\nThis calls the __anext__() method of async_iterator ,\nreturning an awaitable . Awaiting this returns the next value of the\niterator. If default is given, it is returned if the iterator is exhausted,\notherwise StopAsyncIteration is raised.\n\nAdded in version 3.10.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "awaitable anext(async_iterator)"
          },
          "metadata": {
            "signature": "awaitable anext(async_iterator)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "any()",
            "definition": "Return True if any element of the iterable is true.  If the iterable\nis empty, return False .  Equivalent to:",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "any(iterable)",
            "examples": [
              "defany(iterable):forelementiniterable:ifelement:returnTruereturnFalse"
            ]
          },
          "metadata": {
            "signature": "any(iterable)",
            "has_examples": true
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "ascii()",
            "definition": "As repr() , return a string containing a printable representation of an\nobject, but escape the non-ASCII characters in the string returned by repr() using \\x , \\u , or \\U escapes.  This generates a string\nsimilar to that returned by repr() in Python 2.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "ascii(object)"
          },
          "metadata": {
            "signature": "ascii(object)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "bin()",
            "definition": "Convert an integer number to a binary string prefixed with \u201c0b\u201d. The result\nis a valid Python expression. If x is not a Python int object, it\nhas to define an __index__() method that returns an integer. Some\nexamples:\n\nIf the prefix \u201c0b\u201d is desired or not, you can use either of the following ways.\n\nSee also format() for more information.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "bin(x)",
            "examples": [
              ">>>bin(3)'0b11'>>>bin(-10)'-0b1010'",
              ">>>format(14,'#b'),format(14,'b')('0b1110', '1110')>>>f'{14:#b}',f'{14:b}'('0b1110', '1110')"
            ]
          },
          "metadata": {
            "signature": "bin(x)",
            "has_examples": true
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "breakpoint()",
            "definition": "This function drops you into the debugger at the call site.  Specifically,\nit calls sys.breakpointhook() , passing args and kws straight\nthrough.  By default, sys.breakpointhook() calls pdb.set_trace() expecting no arguments.  In this case, it is\npurely a convenience function so you don\u2019t have to explicitly import pdb or type as much code to enter the debugger.  However, sys.breakpointhook() can be set to some other function and breakpoint() will automatically call that, allowing you to drop into\nthe debugger of choice.\nIf sys.breakpointhook() is not accessible, this function will\nraise RuntimeError .\n\nBy default, the behavior of breakpoint() can be changed with\nthe PYTHONBREAKPOINT environment variable.\nSee sys.breakpointhook() for usage details.\n\nNote that this is not guaranteed if sys.breakpointhook() has been replaced.\n\nRaises an auditing event builtins.breakpoint with argument breakpointhook .\n\nAdded in version 3.7.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "breakpoint(*args, **kws)"
          },
          "metadata": {
            "signature": "breakpoint(*args, **kws)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "callable()",
            "definition": "Return True if the object argument appears callable, False if not.  If this returns True , it is still possible that a\ncall fails, but if it is False , calling object will never succeed.\nNote that classes are callable (calling a class returns a new instance);\ninstances are callable if their class has a __call__() method.\n\nAdded in version 3.2: This function was first removed in Python 3.0 and then brought back\nin Python 3.2.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "callable(object)"
          },
          "metadata": {
            "signature": "callable(object)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "chr()",
            "definition": "Return the string representing a character whose Unicode code point is the\ninteger i .  For example, chr(97) returns the string 'a' , while chr(8364) returns the string '\u20ac' . This is the inverse of ord() .\n\nThe valid range for the argument is from 0 through 1,114,111 (0x10FFFF in\nbase 16). ValueError will be raised if i is outside that range.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "chr(i)"
          },
          "metadata": {
            "signature": "chr(i)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "classmethod()",
            "definition": "Transform a method into a class method.\n\nA class method receives the class as an implicit first argument, just like an\ninstance method receives the instance. To declare a class method, use this\nidiom:\n\nThe @classmethod form is a function decorator \u2013 see Function definitions for details.\n\nA class method can be called either on the class (such as C.f() ) or on an instance (such\nas C().f() ).  The instance is ignored except for its class. If a class\nmethod is called for a derived class, the derived class object is passed as the\nimplied first argument.\n\nClass methods are different than C++ or Java static methods. If you want those,\nsee staticmethod() in this section.\nFor more information on class methods, see The standard type hierarchy .\n\nChanged in version 3.9: Class methods can now wrap other descriptors such as property() .\n\nChanged in version 3.10: Class methods now inherit the method attributes\n( __module__ , __name__ , __qualname__ , __doc__ and __annotations__ ) and have a new __wrapped__ attribute.\n\nDeprecated since version 3.11, removed in version 3.13: Class methods can no longer wrap other descriptors such as property() .",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "@classmethod",
            "examples": [
              "classC:@classmethoddeff(cls,arg1,arg2):..."
            ]
          },
          "metadata": {
            "signature": "@classmethod",
            "has_examples": true
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "compile()",
            "definition": "Compile the source into a code or AST object.  Code objects can be executed\nby exec() or eval() . source can either be a normal string, a\nbyte string, or an AST object.  Refer to the ast module documentation\nfor information on how to work with AST objects.\n\nThe filename argument should give the file from which the code was read;\npass some recognizable value if it wasn\u2019t read from a file ( '<string>' is\ncommonly used).\n\nThe mode argument specifies what kind of code must be compiled; it can be 'exec' if source consists of a sequence of statements, 'eval' if it\nconsists of a single expression, or 'single' if it consists of a single\ninteractive statement (in the latter case, expression statements that\nevaluate to something other than None will be printed).\n\nThe optional arguments flags and dont_inherit control which compiler options should be activated\nand which future features should be allowed. If neither\nis present (or both are zero) the code is compiled with the same flags that\naffect the code that is calling compile() . If the flags argument is given and dont_inherit is not (or is zero) then the compiler\noptions and the future statements specified by the flags argument are used\nin addition to those that would be used anyway. If dont_inherit is a\nnon-zero integer then the flags argument is it \u2013 the flags (future\nfeatures and compiler options) in the surrounding code are ignored.\n\nCompiler options and future statements are specified by bits which can be\nbitwise ORed together to specify multiple options. The bitfield required to\nspecify a given future feature can be found as the compiler_flag attribute on the _Feature instance in the __future__ module. Compiler flags can be found in ast module, with PyCF_ prefix.\n\nThe argument optimize specifies the optimization level of the compiler; the\ndefault value of -1 selects the optimization level of the interpreter as\ngiven by -O options.  Explicit levels are 0 (no optimization; __debug__ is true), 1 (asserts are removed, __debug__ is false)\nor 2 (docstrings are removed too).\n\nThis function raises SyntaxError if the compiled source is invalid,\nand ValueError if the source contains null bytes.\n\nIf you want to parse Python code into its AST representation, see ast.parse() .\n\nRaises an auditing event compile with arguments source and filename . This event may also be raised by implicit\ncompilation.\n\nChanged in version 3.2: Allowed use of Windows and Mac newlines.  Also, input in 'exec' mode\ndoes not have to end in a newline anymore.  Added the optimize parameter.\n\nChanged in version 3.5: Previously, TypeError was raised when null bytes were encountered\nin source .\n\nAdded in version 3.8: ast.PyCF_ALLOW_TOP_LEVEL_AWAIT can now be passed in flags to enable\nsupport for top-level await , async for , and async with .\n\nNotes:\n- Note When compiling a string with multi-line code in 'single' or 'eval' mode, input must be terminated by at least one newline\ncharacter.  This is to facilitate detection of incomplete and complete\nstatements in the code module.\n- Warning It is possible to crash the Python interpreter with a\nsufficiently large/complex string when compiling to an AST\nobject due to stack depth limitations in Python\u2019s AST compiler.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1)"
          },
          "metadata": {
            "signature": "compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "delattr()",
            "definition": "This is a relative of setattr() .  The arguments are an object and a\nstring.  The string must be the name of one of the object\u2019s attributes.  The\nfunction deletes the named attribute, provided the object allows it.  For\nexample, delattr(x, 'foobar') is equivalent to del x.foobar . name need not be a Python identifier (see setattr() ).",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "delattr(object, name)"
          },
          "metadata": {
            "signature": "delattr(object, name)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "dir()",
            "definition": "Without arguments, return the list of names in the current local scope.  With an\nargument, attempt to return a list of valid attributes for that object.\n\nIf the object has a method named __dir__() ,\nthis method will be called and\nmust return the list of attributes. This allows objects that implement a custom __getattr__() or __getattribute__() function\nto customize the way dir() reports their attributes.\n\nIf the object does not provide __dir__() ,\nthe function tries its best to gather information from the object\u2019s __dict__ attribute, if defined, and\nfrom its type object.  The resulting list is not necessarily complete and may\nbe inaccurate when the object has a custom __getattr__() .\n\nThe default dir() mechanism behaves differently with different types of\nobjects, as it attempts to produce the most relevant, rather than complete,\ninformation:\n\nIf the object is a module object, the list contains the names of the module\u2019s\nattributes. If the object is a type or class object, the list contains the names of its\nattributes, and recursively of the attributes of its bases. Otherwise, the list contains the object\u2019s attributes\u2019 names, the names of its\nclass\u2019s attributes, and recursively of the attributes of its class\u2019s base\nclasses.\n\nThe resulting list is sorted alphabetically.  For example:\n\nNotes:\n- Note Because dir() is supplied primarily as a convenience for use at an\ninteractive prompt, it tries to supply an interesting set of names more\nthan it tries to supply a rigorously or consistently defined set of names,\nand its detailed behavior may change across releases.  For example,\nmetaclass attributes are not in the result list when the argument is a\nclass.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "dir()",
            "examples": [
              ">>>importstruct>>>dir()# show the names in the module namespace['__builtins__', '__name__', 'struct']>>>dir(struct)# show the names in the struct module['Struct', '__all__', '__builtins__', '__cached__', '__doc__', '__file__','__initializing__', '__loader__', '__name__', '__package__','_clearcache', 'calcsize', 'error', 'pack', 'pack_into','unpack', 'unpack_from']>>>classShape:...def__dir__(self):...return['area','perimeter','location']...>>>s=Shape()>>>dir(s)['area', 'location', 'perimeter']"
            ]
          },
          "metadata": {
            "signature": "dir()",
            "has_examples": true
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "divmod()",
            "definition": "Take two (non-complex) numbers as arguments and return a pair of numbers\nconsisting of their quotient and remainder when using integer division.  With\nmixed operand types, the rules for binary arithmetic operators apply.  For\nintegers, the result is the same as (a // b, a % b) . For floating-point\nnumbers the result is (q, a % b) , where q is usually math.floor(a / b) but may be 1 less than that.  In any case q * b + a % b is very\nclose to a , if a % b is non-zero it has the same sign as b , and 0 <= abs(a % b) < abs(b) .",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "divmod(a, b)"
          },
          "metadata": {
            "signature": "divmod(a, b)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "enumerate()",
            "definition": "Return an enumerate object. iterable must be a sequence, an iterator , or some other object which supports iteration.\nThe __next__() method of the iterator returned by enumerate() returns a tuple containing a count (from start which\ndefaults to 0) and the values obtained from iterating over iterable .\n\nEquivalent to:",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "enumerate(iterable, start=0)",
            "examples": [
              ">>>seasons=['Spring','Summer','Fall','Winter']>>>list(enumerate(seasons))[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]>>>list(enumerate(seasons,start=1))[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]",
              "defenumerate(iterable,start=0):n=startforeleminiterable:yieldn,elemn+=1"
            ]
          },
          "metadata": {
            "signature": "enumerate(iterable, start=0)",
            "has_examples": true
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "eval()",
            "definition": "Parameters : source ( str | code object ) \u2013 A Python expression. globals ( dict | None ) \u2013 The global namespace (default: None ). locals ( mapping | None ) \u2013 The local namespace (default: None ). Returns : The result of the evaluated expression. Raises : Syntax errors are reported as exceptions.\n\nThe expression argument is parsed and evaluated as a Python expression\n(technically speaking, a condition list) using the globals and locals mappings as global and local namespace.  If the globals dictionary is\npresent and does not contain a value for the key __builtins__ , a\nreference to the dictionary of the built-in module builtins is\ninserted under that key before expression is parsed.  That way you can\ncontrol what builtins are available to the executed code by inserting your\nown __builtins__ dictionary into globals before passing it to eval() .  If the locals mapping is omitted it defaults to the globals dictionary.  If both mappings are omitted, the expression is\nexecuted with the globals and locals in the environment where eval() is called.  Note, eval() will only have access to the nested scopes (non-locals) in the enclosing\nenvironment if they are already referenced in the scope that is calling eval() (e.g. via a nonlocal statement).\n\nExample:\n\nThis function can also be used to execute arbitrary code objects (such as\nthose created by compile() ).  In this case, pass a code object instead\nof a string.  If the code object has been compiled with 'exec' as the mode argument, eval() 's return value will be None .\n\nHints: dynamic execution of statements is supported by the exec() function.  The globals() and locals() functions\nreturn the current global and local dictionary, respectively, which may be\nuseful to pass around for use by eval() or exec() .\n\nIf the given source is a string, then leading and trailing spaces and tabs\nare stripped.\n\nSee ast.literal_eval() for a function that can safely evaluate strings\nwith expressions containing only literals.\n\nRaises an auditing event exec with the code object\nas the argument. Code compilation events may also be raised.\n\nChanged in version 3.13: The globals and locals arguments can now be passed as keywords.\n\nChanged in version 3.13: The semantics of the default locals namespace have been adjusted as\ndescribed for the locals() builtin.\n\nNotes:\n- Warning This function executes arbitrary code. Calling it with\nuser-supplied input may lead to security vulnerabilities.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "eval(source, /, globals=None, locals=None)",
            "examples": [
              ">>>x=1>>>eval('x+1')2"
            ]
          },
          "metadata": {
            "signature": "eval(source, /, globals=None, locals=None)",
            "has_examples": true
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "exec()",
            "definition": "This function supports dynamic execution of Python code. source must be\neither a string or a code object.  If it is a string, the string is parsed as\na suite of Python statements which is then executed (unless a syntax error\noccurs). [ 1 ] If it is a code object, it is simply executed.  In all cases,\nthe code that\u2019s executed is expected to be valid as file input (see the\nsection File input in the Reference Manual). Be aware that the nonlocal , yield ,  and return statements may not be used outside of\nfunction definitions even within the context of code passed to the exec() function. The return value is None .\n\nIn all cases, if the optional parts are omitted, the code is executed in the\ncurrent scope.  If only globals is provided, it must be a dictionary\n(and not a subclass of dictionary), which\nwill be used for both the global and the local variables.  If globals and locals are given, they are used for the global and local variables,\nrespectively.  If provided, locals can be any mapping object.  Remember\nthat at the module level, globals and locals are the same dictionary.\n\nIf the globals dictionary does not contain a value for the key __builtins__ , a reference to the dictionary of the built-in module builtins is inserted under that key.  That way you can control what\nbuiltins are available to the executed code by inserting your own __builtins__ dictionary into globals before passing it to exec() .\n\nThe closure argument specifies a closure\u2013a tuple of cellvars.\nIt\u2019s only valid when the object is a code object containing free (closure) variables .\nThe length of the tuple must exactly match the length of the code object\u2019s co_freevars attribute.\n\nRaises an auditing event exec with the code object\nas the argument. Code compilation events may also be raised.\n\nChanged in version 3.11: Added the closure parameter.\n\nChanged in version 3.13: The globals and locals arguments can now be passed as keywords.\n\nChanged in version 3.13: The semantics of the default locals namespace have been adjusted as\ndescribed for the locals() builtin.\n\nNotes:\n- Warning This function executes arbitrary code. Calling it with\nuser-supplied input may lead to security vulnerabilities.\n- Note When exec gets two separate objects as globals and locals , the\ncode will be executed as if it were embedded in a class definition. This\nmeans functions and classes defined in the executed code will not be able\nto access variables assigned at the top level (as the \u201ctop level\u201d\nvariables are treated as class variables in a class definition).\n- Note The built-in functions globals() and locals() return the current\nglobal and local namespace, respectively, which may be useful to pass around\nfor use as the second and third argument to exec() .\n- Note The default locals act as described for function locals() below.\nPass an explicit locals dictionary if you need to see effects of the\ncode on locals after function exec() returns.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "exec(source, /, globals=None, locals=None, *, closure=None)"
          },
          "metadata": {
            "signature": "exec(source, /, globals=None, locals=None, *, closure=None)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "filter()",
            "definition": "Construct an iterator from those elements of iterable for which function is true. iterable may be either a sequence, a container which\nsupports iteration, or an iterator.  If function is None , the identity\nfunction is assumed, that is, all elements of iterable that are false are\nremoved.\n\nNote that filter(function, iterable) is equivalent to the generator\nexpression (item for item in iterable if function(item)) if function is\nnot None and (item for item in iterable if item) if function is None .\n\nSee itertools.filterfalse() for the complementary function that returns\nelements of iterable for which function is false.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "filter(function, iterable)"
          },
          "metadata": {
            "signature": "filter(function, iterable)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "format()",
            "definition": "Convert a value to a \u201cformatted\u201d representation, as controlled by format_spec .  The interpretation of format_spec will depend on the type\nof the value argument; however, there is a standard formatting syntax that\nis used by most built-in types: Format Specification Mini-Language .\n\nThe default format_spec is an empty string which usually gives the same\neffect as calling str(value) .\n\nA call to format(value, format_spec) is translated to type(value).__format__(value, format_spec) which bypasses the instance\ndictionary when searching for the value\u2019s __format__() method.\nA TypeError exception is raised if the method search reaches object and the format_spec is non-empty, or if either the format_spec or the return value are not strings.\n\nChanged in version 3.4: object().__format__(format_spec) raises TypeError if format_spec is not an empty string.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "format(value, format_spec='')"
          },
          "metadata": {
            "signature": "format(value, format_spec='')",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "getattr()",
            "definition": "Return the value of the named attribute of object . name must be a string.\nIf the string is the name of one of the object\u2019s attributes, the result is the\nvalue of that attribute.  For example, getattr(x, 'foobar') is equivalent to x.foobar .  If the named attribute does not exist, default is returned if\nprovided, otherwise AttributeError is raised. name need not be a Python identifier (see setattr() ).\n\nNotes:\n- Note Since private name mangling happens at\ncompilation time, one must manually mangle a private attribute\u2019s\n(attributes with two leading underscores) name in order to retrieve it with getattr() .",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "getattr(object, name)"
          },
          "metadata": {
            "signature": "getattr(object, name)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "globals()",
            "definition": "Return the dictionary implementing the current module namespace. For code within\nfunctions, this is set when the function is defined and remains the same\nregardless of where the function is called.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "globals()"
          },
          "metadata": {
            "signature": "globals()",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "hasattr()",
            "definition": "The arguments are an object and a string.  The result is True if the\nstring is the name of one of the object\u2019s attributes, False if not. (This\nis implemented by calling getattr(object, name) and seeing whether it\nraises an AttributeError or not.)",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "hasattr(object, name)"
          },
          "metadata": {
            "signature": "hasattr(object, name)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "hash()",
            "definition": "Return the hash value of the object (if it has one).  Hash values are\nintegers.  They are used to quickly compare dictionary keys during a\ndictionary lookup.  Numeric values that compare equal have the same hash\nvalue (even if they are of different types, as is the case for 1 and 1.0).\n\nNotes:\n- Note For objects with custom __hash__() methods,\nnote that hash() truncates the return value based on the bit width of the host machine.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "hash(object)"
          },
          "metadata": {
            "signature": "hash(object)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "help()",
            "definition": "Invoke the built-in help system.  (This function is intended for interactive\nuse.)  If no argument is given, the interactive help system starts on the\ninterpreter console.  If the argument is a string, then the string is looked up\nas the name of a module, function, class, method, keyword, or documentation\ntopic, and a help page is printed on the console.  If the argument is any other\nkind of object, a help page on the object is generated.\n\nNote that if a slash(/) appears in the parameter list of a function when\ninvoking help() , it means that the parameters prior to the slash are\npositional-only. For more info, see the FAQ entry on positional-only parameters .\n\nThis function is added to the built-in namespace by the site module.\n\nChanged in version 3.4: Changes to pydoc and inspect mean that the reported\nsignatures for callables are now more comprehensive and consistent.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "help()"
          },
          "metadata": {
            "signature": "help()",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "hex()",
            "definition": "Convert an integer number to a lowercase hexadecimal string prefixed with\n\u201c0x\u201d. If x is not a Python int object, it has to define an __index__() method that returns an integer. Some examples:\n\nIf you want to convert an integer number to an uppercase or lower hexadecimal\nstring with prefix or not, you can use either of the following ways:\n\nSee also format() for more information.\n\nSee also int() for converting a hexadecimal string to an\ninteger using a base of 16.\n\nNotes:\n- Note To obtain a hexadecimal string representation for a float, use the float.hex() method.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "hex(x)",
            "examples": [
              ">>>hex(255)'0xff'>>>hex(-42)'-0x2a'",
              ">>>'%#x'%255,'%x'%255,'%X'%255('0xff', 'ff', 'FF')>>>format(255,'#x'),format(255,'x'),format(255,'X')('0xff', 'ff', 'FF')>>>f'{255:#x}',f'{255:x}',f'{255:X}'('0xff', 'ff', 'FF')"
            ]
          },
          "metadata": {
            "signature": "hex(x)",
            "has_examples": true
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "id()",
            "definition": "Return the \u201cidentity\u201d of an object.  This is an integer which\nis guaranteed to be unique and constant for this object during its lifetime.\nTwo objects with non-overlapping lifetimes may have the same id() value.\n\nCPython implementation detail: This is the address of the object in memory.\n\nRaises an auditing event builtins.id with argument id .",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "id(object)"
          },
          "metadata": {
            "signature": "id(object)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "input()",
            "definition": "If the prompt argument is present, it is written to standard output without\na trailing newline.  The function then reads a line from input, converts it\nto a string (stripping a trailing newline), and returns that.  When EOF is\nread, EOFError is raised.  Example:\n\nIf the readline module was loaded, then input() will use it\nto provide elaborate line editing and history features.\n\nRaises an auditing event builtins.input with\nargument prompt before reading input\n\nRaises an auditing event builtins.input/result with the result after successfully reading input.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "input()",
            "examples": [
              ">>>s=input('--> ')--> Monty Python's Flying Circus>>>s\"Monty Python's Flying Circus\""
            ]
          },
          "metadata": {
            "signature": "input()",
            "has_examples": true
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "isinstance()",
            "definition": "Return True if the object argument is an instance of the classinfo argument, or of a (direct, indirect, or virtual ) subclass thereof.  If object is not\nan object of the given type, the function always returns False .\nIf classinfo is a tuple of type objects (or recursively, other such\ntuples) or a Union Type of multiple types, return True if object is an instance of any of the types.\nIf classinfo is not a type or tuple of types and such tuples,\na TypeError exception is raised. TypeError may not be\nraised for an invalid type if an earlier check succeeds.\n\nChanged in version 3.10: classinfo can be a Union Type .",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "isinstance(object, classinfo)"
          },
          "metadata": {
            "signature": "isinstance(object, classinfo)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "issubclass()",
            "definition": "Return True if class is a subclass (direct, indirect, or virtual ) of classinfo .  A\nclass is considered a subclass of itself. classinfo may be a tuple of class\nobjects (or recursively, other such tuples)\nor a Union Type , in which case return True if class is a\nsubclass of any entry in classinfo .  In any other case, a TypeError exception is raised.\n\nChanged in version 3.10: classinfo can be a Union Type .",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "issubclass(class, classinfo)"
          },
          "metadata": {
            "signature": "issubclass(class, classinfo)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "iter()",
            "definition": "Return an iterator object.  The first argument is interpreted very\ndifferently depending on the presence of the second argument. Without a\nsecond argument, object must be a collection object which supports the iterable protocol (the __iter__() method),\nor it must support\nthe sequence protocol (the __getitem__() method with integer arguments\nstarting at 0 ).  If it does not support either of those protocols, TypeError is raised. If the second argument, sentinel , is given,\nthen object must be a callable object.  The iterator created in this case\nwill call object with no arguments for each call to its __next__() method; if the value returned is equal to sentinel , StopIteration will be raised, otherwise the value will\nbe returned.\n\nSee also Iterator Types .\n\nOne useful application of the second form of iter() is to build a\nblock-reader. For example, reading fixed-width blocks from a binary\ndatabase file until the end of file is reached:",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "iter(object)",
            "examples": [
              "fromfunctoolsimportpartialwithopen('mydata.db','rb')asf:forblockiniter(partial(f.read,64),b''):process_block(block)"
            ]
          },
          "metadata": {
            "signature": "iter(object)",
            "has_examples": true
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "len()",
            "definition": "Return the length (the number of items) of an object.  The argument may be a\nsequence (such as a string, bytes, tuple, list, or range) or a collection\n(such as a dictionary, set, or frozen set).\n\nCPython implementation detail: len raises OverflowError on lengths larger than sys.maxsize , such as range(2 ** 100) .",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "len(s)"
          },
          "metadata": {
            "signature": "len(s)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "locals()",
            "definition": "Return a mapping object representing the current local symbol table, with\nvariable names as the keys, and their currently bound references as the\nvalues.\n\nAt module scope, as well as when using exec() or eval() with\na single namespace, this function returns the same namespace as globals() .\n\nAt class scope, it returns the namespace that will be passed to the\nmetaclass constructor.\n\nWhen using exec() or eval() with separate local and global\narguments, it returns the local namespace passed in to the function call.\n\nIn all of the above cases, each call to locals() in a given frame of\nexecution will return the same mapping object. Changes made through\nthe mapping object returned from locals() will be visible as assigned,\nreassigned, or deleted local variables, and assigning, reassigning, or\ndeleting local variables will immediately affect the contents of the\nreturned mapping object.\n\nIn an optimized scope (including functions, generators, and\ncoroutines), each call to locals() instead returns a fresh dictionary\ncontaining the current bindings of the function\u2019s local variables and any\nnonlocal cell references. In this case, name binding changes made via the\nreturned dict are not written back to the corresponding local variables\nor nonlocal cell references, and assigning, reassigning, or deleting local\nvariables and nonlocal cell references does not affect the contents\nof previously returned dictionaries.\n\nCalling locals() as part of a comprehension in a function, generator, or\ncoroutine is equivalent to calling it in the containing scope, except that\nthe comprehension\u2019s initialised iteration variables will be included. In\nother scopes, it behaves as if the comprehension were running as a nested\nfunction.\n\nCalling locals() as part of a generator expression is equivalent to\ncalling it in a nested generator function.\n\nChanged in version 3.12: The behaviour of locals() in a comprehension has been updated as\ndescribed in PEP 709 .\n\nChanged in version 3.13: As part of PEP 667 , the semantics of mutating the mapping objects\nreturned from this function are now defined. The behavior in optimized scopes is now as described above.\nAside from being defined, the behaviour in other scopes remains\nunchanged from previous versions.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "locals()"
          },
          "metadata": {
            "signature": "locals()",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "map()",
            "definition": "Return an iterator that applies function to every item of iterable ,\nyielding the results.  If additional iterables arguments are passed, function must take that many arguments and is applied to the items from all\niterables in parallel.  With multiple iterables, the iterator stops when the\nshortest iterable is exhausted.  For cases where the function inputs are\nalready arranged into argument tuples, see itertools.starmap() .",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "map(function, iterable, *iterables)"
          },
          "metadata": {
            "signature": "map(function, iterable, *iterables)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "max()",
            "definition": "Return the largest item in an iterable or the largest of two or more\narguments.\n\nIf one positional argument is provided, it should be an iterable .\nThe largest item in the iterable is returned.  If two or more positional\narguments are provided, the largest of the positional arguments is\nreturned.\n\nThere are two optional keyword-only arguments. The key argument specifies\na one-argument ordering function like that used for list.sort() . The default argument specifies an object to return if the provided iterable is\nempty. If the iterable is empty and default is not provided, a ValueError is raised.\n\nIf multiple items are maximal, the function returns the first one\nencountered.  This is consistent with other sort-stability preserving tools\nsuch as sorted(iterable, key=keyfunc, reverse=True)[0] and heapq.nlargest(1, iterable, key=keyfunc) .\n\nChanged in version 3.4: Added the default keyword-only parameter.\n\nChanged in version 3.8: The key can be None .",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "max(iterable, *, key=None)"
          },
          "metadata": {
            "signature": "max(iterable, *, key=None)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "min()",
            "definition": "Return the smallest item in an iterable or the smallest of two or more\narguments.\n\nIf one positional argument is provided, it should be an iterable .\nThe smallest item in the iterable is returned.  If two or more positional\narguments are provided, the smallest of the positional arguments is\nreturned.\n\nThere are two optional keyword-only arguments. The key argument specifies\na one-argument ordering function like that used for list.sort() . The default argument specifies an object to return if the provided iterable is\nempty. If the iterable is empty and default is not provided, a ValueError is raised.\n\nIf multiple items are minimal, the function returns the first one\nencountered.  This is consistent with other sort-stability preserving tools\nsuch as sorted(iterable, key=keyfunc)[0] and heapq.nsmallest(1, iterable, key=keyfunc) .\n\nChanged in version 3.4: Added the default keyword-only parameter.\n\nChanged in version 3.8: The key can be None .",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "min(iterable, *, key=None)"
          },
          "metadata": {
            "signature": "min(iterable, *, key=None)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "next()",
            "definition": "Retrieve the next item from the iterator by calling its __next__() method.  If default is given, it is returned\nif the iterator is exhausted, otherwise StopIteration is raised.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "next(iterator)"
          },
          "metadata": {
            "signature": "next(iterator)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "oct()",
            "definition": "Convert an integer number to an octal string prefixed with \u201c0o\u201d.  The result\nis a valid Python expression. If x is not a Python int object, it\nhas to define an __index__() method that returns an integer. For\nexample:\n\nIf you want to convert an integer number to an octal string either with the prefix\n\u201c0o\u201d or not, you can use either of the following ways.\n\nSee also format() for more information.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "oct(x)",
            "examples": [
              ">>>oct(8)'0o10'>>>oct(-56)'-0o70'",
              ">>>'%#o'%10,'%o'%10('0o12', '12')>>>format(10,'#o'),format(10,'o')('0o12', '12')>>>f'{10:#o}',f'{10:o}'('0o12', '12')"
            ]
          },
          "metadata": {
            "signature": "oct(x)",
            "has_examples": true
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "open()",
            "definition": "Open file and return a corresponding file object .  If the file\ncannot be opened, an OSError is raised. See Reading and Writing Files for more examples of how to use this function.\n\nfile is a path-like object giving the pathname (absolute or\nrelative to the current working directory) of the file to be opened or an\ninteger file descriptor of the file to be wrapped.  (If a file descriptor is\ngiven, it is closed when the returned I/O object is closed unless closefd is set to False .)\n\nmode is an optional string that specifies the mode in which the file is\nopened.  It defaults to 'r' which means open for reading in text mode.\nOther common values are 'w' for writing (truncating the file if it\nalready exists), 'x' for exclusive creation, and 'a' for appending\n(which on some Unix systems, means that all writes append to the end of\nthe file regardless of the current seek position).  In text mode, if encoding is not specified the encoding used is platform-dependent: locale.getencoding() is called to get the current locale encoding.\n(For reading and writing raw bytes use binary mode and leave encoding unspecified.)  The available modes are:\n\nCharacter Meaning 'r' open for reading (default) 'w' open for writing, truncating the file first 'x' open for exclusive creation, failing if the file already exists 'a' open for writing, appending to the end of file if it exists 'b' binary mode 't' text mode (default) '+' open for updating (reading and writing)\n\nThe default mode is 'r' (open for reading text, a synonym of 'rt' ).\nModes 'w+' and 'w+b' open and truncate the file.  Modes 'r+' and 'r+b' open the file with no truncation.\n\nAs mentioned in the Overview , Python distinguishes between binary\nand text I/O.  Files opened in binary mode (including 'b' in the mode argument) return contents as bytes objects without any decoding.  In\ntext mode (the default, or when 't' is included in the mode argument),\nthe contents of the file are returned as str , the bytes having been\nfirst decoded using a platform-dependent encoding or using the specified encoding if given.\n\nbuffering is an optional integer used to set the buffering policy.  Pass 0\nto switch buffering off (only allowed in binary mode), 1 to select line\nbuffering (only usable when writing in text mode), and an integer > 1 to indicate the size\nin bytes of a fixed-size chunk buffer. Note that specifying a buffer size this\nway applies for binary buffered I/O, but TextIOWrapper (i.e., files opened\nwith mode='r+' ) would have another buffering. To disable buffering in TextIOWrapper , consider using the write_through flag for io.TextIOWrapper.reconfigure() . When no buffering argument is\ngiven, the default buffering policy works as follows:\n\nBinary files are buffered in fixed-size chunks; the size of the buffer is\nchosen using a heuristic trying to determine the underlying device\u2019s \u201cblock\nsize\u201d and falling back on io.DEFAULT_BUFFER_SIZE .  On many systems,\nthe buffer will typically be 4096 or 8192 bytes long. \u201cInteractive\u201d text files (files for which isatty() returns True ) use line buffering.  Other text files use the policy\ndescribed above for binary files.\n\nencoding is the name of the encoding used to decode or encode the file.\nThis should only be used in text mode.  The default encoding is platform\ndependent (whatever locale.getencoding() returns), but any text encoding supported by Python can be used.\nSee the codecs module for the list of supported encodings.\n\nerrors is an optional string that specifies how encoding and decoding\nerrors are to be handled\u2014this cannot be used in binary mode.\nA variety of standard error handlers are available\n(listed under Error Handlers ), though any\nerror handling name that has been registered with codecs.register_error() is also valid.  The standard names\ninclude:\n\n'strict' to raise a ValueError exception if there is\nan encoding error.  The default value of None has the same\neffect. 'ignore' ignores errors.  Note that ignoring encoding errors\ncan lead to data loss. 'replace' causes a replacement marker (such as '?' ) to be inserted\nwhere there is malformed data. 'surrogateescape' will represent any incorrect bytes as low\nsurrogate code units ranging from U+DC80 to U+DCFF.\nThese surrogate code units will then be turned back into\nthe same bytes when the surrogateescape error handler is used\nwhen writing data.  This is useful for processing files in an\nunknown encoding. 'xmlcharrefreplace' is only supported when writing to a file.\nCharacters not supported by the encoding are replaced with the\nappropriate XML character reference &# nnn ; . 'backslashreplace' replaces malformed data by Python\u2019s backslashed\nescape sequences. 'namereplace' (also only supported when writing)\nreplaces unsupported characters with \\N{...} escape sequences.\n\nnewline determines how to parse newline characters from the stream.\nIt can be None , '' , '\\n' , '\\r' , and '\\r\\n' .  It works as follows:\n\nWhen reading input from the stream, if newline is None , universal\nnewlines mode is enabled.  Lines in the input can end in '\\n' , '\\r' , or '\\r\\n' , and these are translated into '\\n' before\nbeing returned to the caller.  If it is '' , universal newlines mode is\nenabled, but line endings are returned to the caller untranslated.  If it\nhas any of the other legal values, input lines are only terminated by the\ngiven string, and the line ending is returned to the caller untranslated. When writing output to the stream, if newline is None , any '\\n' characters written are translated to the system default line separator, os.linesep .  If newline is '' or '\\n' , no translation\ntakes place.  If newline is any of the other legal values, any '\\n' characters written are translated to the given string.\n\nIf closefd is False and a file descriptor rather than a filename was\ngiven, the underlying file descriptor will be kept open when the file is\nclosed.  If a filename is given closefd must be True (the default);\notherwise, an error will be raised.\n\nA custom opener can be used by passing a callable as opener . The underlying\nfile descriptor for the file object is then obtained by calling opener with\n( file , flags ). opener must return an open file descriptor (passing os.open as opener results in functionality similar to passing None ).\n\nThe newly created file is non-inheritable .\n\nThe following example uses the dir_fd parameter of the os.open() function to open a file relative to a given directory:\n\nThe type of file object returned by the open() function\ndepends on the mode.  When open() is used to open a file in a text\nmode ( 'w' , 'r' , 'wt' , 'rt' , etc.), it returns a subclass of io.TextIOBase (specifically io.TextIOWrapper ).  When used\nto open a file in a binary mode with buffering, the returned class is a\nsubclass of io.BufferedIOBase .  The exact class varies: in read\nbinary mode, it returns an io.BufferedReader ; in write binary and\nappend binary modes, it returns an io.BufferedWriter , and in\nread/write mode, it returns an io.BufferedRandom .  When buffering is\ndisabled, the raw stream, a subclass of io.RawIOBase , io.FileIO , is returned.\n\nSee also the file handling modules, such as fileinput , io (where open() is declared), os , os.path , tempfile ,\nand shutil .\n\nRaises an auditing event open with arguments path , mode , flags .\n\nThe mode and flags arguments may have been modified or inferred from\nthe original call.\n\nChanged in version 3.3: The opener parameter was added. The 'x' mode was added. IOError used to be raised, it is now an alias of OSError . FileExistsError is now raised if the file opened in exclusive\ncreation mode ( 'x' ) already exists.\n\nChanged in version 3.4: The file is now non-inheritable.\n\nChanged in version 3.5: If the system call is interrupted and the signal handler does not raise an\nexception, the function now retries the system call instead of raising an InterruptedError exception (see PEP 475 for the rationale). The 'namereplace' error handler was added.\n\nChanged in version 3.6: Support added to accept objects implementing os.PathLike . On Windows, opening a console buffer may return a subclass of io.RawIOBase other than io.FileIO .\n\nChanged in version 3.11: The 'U' mode has been removed.\n\nNotes:\n- Note Python doesn\u2019t depend on the underlying operating system\u2019s notion of text\nfiles; all the processing is done by Python itself, and is therefore\nplatform-independent.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)",
            "examples": [
              ">>>importos>>>dir_fd=os.open('somedir',os.O_RDONLY)>>>defopener(path,flags):...returnos.open(path,flags,dir_fd=dir_fd)...>>>withopen('spamspam.txt','w',opener=opener)asf:...print('This will be written to somedir/spamspam.txt',file=f)...>>>os.close(dir_fd)# don't leak a file descriptor"
            ]
          },
          "metadata": {
            "signature": "open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)",
            "has_examples": true
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "ord()",
            "definition": "Given a string representing one Unicode character, return an integer\nrepresenting the Unicode code point of that character.  For example, ord('a') returns the integer 97 and ord('\u20ac') (Euro sign)\nreturns 8364 .  This is the inverse of chr() .",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "ord(c)"
          },
          "metadata": {
            "signature": "ord(c)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "pow()",
            "definition": "Return base to the power exp ; if mod is present, return base to the\npower exp , modulo mod (computed more efficiently than pow(base, exp) % mod ). The two-argument form pow(base, exp) is\nequivalent to using the power operator: base**exp .\n\nThe arguments must have numeric types.  With mixed operand types, the\ncoercion rules for binary arithmetic operators apply.  For int operands, the result has the same type as the operands (after coercion)\nunless the second argument is negative; in that case, all arguments are\nconverted to float and a float result is delivered.  For example, pow(10, 2) returns 100 , but pow(10, -2) returns 0.01 .  For a negative base of\ntype int or float and a non-integral exponent, a complex\nresult is delivered.  For example, pow(-9, 0.5) returns a value close\nto 3j . Whereas, for a negative base of type int or float with an integral exponent, a float result is delivered. For example, pow(-9, 2.0) returns 81.0 .\n\nFor int operands base and exp , if mod is present, mod must\nalso be of integer type and mod must be nonzero. If mod is present and exp is negative, base must be relatively prime to mod . In that case, pow(inv_base, -exp, mod) is returned, where inv_base is an inverse to base modulo mod .\n\nHere\u2019s an example of computing an inverse for 38 modulo 97 :\n\nChanged in version 3.8: For int operands, the three-argument form of pow now allows\nthe second argument to be negative, permitting computation of modular\ninverses.\n\nChanged in version 3.8: Allow keyword arguments.  Formerly, only positional arguments were\nsupported.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "pow(base, exp, mod=None)",
            "examples": [
              ">>>pow(38,-1,mod=97)23>>>23*38%97==1True"
            ]
          },
          "metadata": {
            "signature": "pow(base, exp, mod=None)",
            "has_examples": true
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "print()",
            "definition": "Print objects to the text stream file , separated by sep and followed\nby end . sep , end , file , and flush , if present, must be given as keyword\narguments.\n\nAll non-keyword arguments are converted to strings like str() does and\nwritten to the stream, separated by sep and followed by end .  Both sep and end must be strings; they can also be None , which means to use the\ndefault values.  If no objects are given, print() will just write end .\n\nThe file argument must be an object with a write(string) method; if it\nis not present or None , sys.stdout will be used.  Since printed\narguments are converted to text strings, print() cannot be used with\nbinary mode file objects.  For these, use file.write(...) instead.\n\nOutput buffering is usually determined by file .\nHowever, if flush is true, the stream is forcibly flushed.\n\nChanged in version 3.3: Added the flush keyword argument.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "print(*objects, sep=' ', end='\\n', file=None, flush=False)"
          },
          "metadata": {
            "signature": "print(*objects, sep=' ', end='\\n', file=None, flush=False)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "property.getter()",
            "definition": "Python built-in function: property.getter()",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "@getter"
          },
          "metadata": {
            "signature": "@getter",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "property.setter()",
            "definition": "Python built-in function: property.setter()",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "@setter"
          },
          "metadata": {
            "signature": "@setter",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "property.deleter()",
            "definition": "A property object has getter , setter ,\nand deleter methods usable as decorators that create a\ncopy of the property with the corresponding accessor function set to the\ndecorated function.  This is best explained with an example:\n\nThis code is exactly equivalent to the first example.  Be sure to give the\nadditional functions the same name as the original property ( x in this\ncase.)\n\nThe returned property object also has the attributes fget , fset , and fdel corresponding to the constructor arguments.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "@deleter",
            "examples": [
              "classC:def__init__(self):self._x=None@propertydefx(self):\"\"\"I'm the 'x' property.\"\"\"returnself._x@x.setterdefx(self,value):self._x=value@x.deleterdefx(self):delself._x"
            ]
          },
          "metadata": {
            "signature": "@deleter",
            "has_examples": true
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "repr()",
            "definition": "Return a string containing a printable representation of an object.  For many\ntypes, this function makes an attempt to return a string that would yield an\nobject with the same value when passed to eval() ; otherwise, the\nrepresentation is a string enclosed in angle brackets that contains the name\nof the type of the object together with additional information often\nincluding the name and address of the object.  A class can control what this\nfunction returns for its instances\nby defining a __repr__() method.\nIf sys.displayhook() is not accessible, this function will raise RuntimeError .\n\nThis class has a custom representation that can be evaluated:",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "repr(object)",
            "examples": [
              "classPerson:def__init__(self,name,age):self.name=nameself.age=agedef__repr__(self):returnf\"Person('{self.name}',{self.age})\""
            ]
          },
          "metadata": {
            "signature": "repr(object)",
            "has_examples": true
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "reversed()",
            "definition": "Return a reverse iterator . seq must be an object which has\na __reversed__() method or supports the sequence protocol (the __len__() method and the __getitem__() method\nwith integer arguments starting at 0 ).",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "reversed(seq)"
          },
          "metadata": {
            "signature": "reversed(seq)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "round()",
            "definition": "Return number rounded to ndigits precision after the decimal\npoint.  If ndigits is omitted or is None , it returns the\nnearest integer to its input.\n\nFor the built-in types supporting round() , values are rounded to the\nclosest multiple of 10 to the power minus ndigits ; if two multiples are\nequally close, rounding is done toward the even choice (so, for example,\nboth round(0.5) and round(-0.5) are 0 , and round(1.5) is 2 ).  Any integer value is valid for ndigits (positive, zero, or\nnegative).  The return value is an integer if ndigits is omitted or None .\nOtherwise, the return value has the same type as number .\n\nFor a general Python object number , round delegates to number.__round__ .\n\nNotes:\n- Note The behavior of round() for floats can be surprising: for example, round(2.675, 2) gives 2.67 instead of the expected 2.68 .\nThis is not a bug: it\u2019s a result of the fact that most decimal fractions\ncan\u2019t be represented exactly as a float.  See Floating-Point Arithmetic:  Issues and Limitations for\nmore information.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "round(number, ndigits=None)"
          },
          "metadata": {
            "signature": "round(number, ndigits=None)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "setattr()",
            "definition": "This is the counterpart of getattr() .  The arguments are an object, a\nstring, and an arbitrary value.  The string may name an existing attribute or a\nnew attribute.  The function assigns the value to the attribute, provided the\nobject allows it.  For example, setattr(x, 'foobar', 123) is equivalent to x.foobar = 123 .\n\nname need not be a Python identifier as defined in Identifiers and keywords unless the object chooses to enforce that, for example in a custom __getattribute__() or via __slots__ .\nAn attribute whose name is not an identifier will not be accessible using\nthe dot notation, but is accessible through getattr() etc..\n\nNotes:\n- Note Since private name mangling happens at\ncompilation time, one must manually mangle a private attribute\u2019s\n(attributes with two leading underscores) name in order to set it with setattr() .",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "setattr(object, name, value)"
          },
          "metadata": {
            "signature": "setattr(object, name, value)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "sorted()",
            "definition": "Return a new sorted list from the items in iterable .\n\nHas two optional arguments which must be specified as keyword arguments.\n\nkey specifies a function of one argument that is used to extract a comparison\nkey from each element in iterable (for example, key=str.lower ).  The\ndefault value is None (compare the elements directly).\n\nreverse is a boolean value.  If set to True , then the list elements are\nsorted as if each comparison were reversed.\n\nUse functools.cmp_to_key() to convert an old-style cmp function to a key function.\n\nThe built-in sorted() function is guaranteed to be stable. A sort is\nstable if it guarantees not to change the relative order of elements that\ncompare equal \u2014 this is helpful for sorting in multiple passes (for\nexample, sort by department, then by salary grade).\n\nThe sort algorithm uses only < comparisons between items.  While\ndefining an __lt__() method will suffice for sorting, PEP 8 recommends that all six rich comparisons be implemented.  This will help avoid bugs when using\nthe same data with other ordering tools such as max() that rely\non a different underlying method.  Implementing all six comparisons\nalso helps avoid confusion for mixed type comparisons which can call\nreflected the __gt__() method.\n\nFor sorting examples and a brief sorting tutorial, see Sorting Techniques .",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "sorted(iterable, /, *, key=None, reverse=False)"
          },
          "metadata": {
            "signature": "sorted(iterable, /, *, key=None, reverse=False)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "staticmethod()",
            "definition": "Transform a method into a static method.\n\nA static method does not receive an implicit first argument. To declare a static\nmethod, use this idiom:\n\nThe @staticmethod form is a function decorator \u2013 see Function definitions for details.\n\nA static method can be called either on the class (such as C.f() ) or on\nan instance (such as C().f() ).\nMoreover, the static method descriptor is also callable, so it can\nbe used in the class definition (such as f() ).\n\nStatic methods in Python are similar to those found in Java or C++. Also, see classmethod() for a variant that is useful for creating alternate class\nconstructors.\n\nLike all decorators, it is also possible to call staticmethod as\na regular function and do something with its result.  This is needed\nin some cases where you need a reference to a function from a class\nbody and you want to avoid the automatic transformation to instance\nmethod.  For these cases, use this idiom:\n\nFor more information on static methods, see The standard type hierarchy .\n\nChanged in version 3.10: Static methods now inherit the method attributes\n( __module__ , __name__ , __qualname__ , __doc__ and __annotations__ ), have a new __wrapped__ attribute,\nand are now callable as regular functions.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "@staticmethod",
            "examples": [
              "classC:@staticmethoddeff(arg1,arg2,argN):...",
              "defregular_function():...classC:method=staticmethod(regular_function)"
            ]
          },
          "metadata": {
            "signature": "@staticmethod",
            "has_examples": true
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "sum()",
            "definition": "Sums start and the items of an iterable from left to right and returns the\ntotal.  The iterable \u2019s items are normally numbers, and the start value is not\nallowed to be a string.\n\nFor some use cases, there are good alternatives to sum() .\nThe preferred, fast way to concatenate a sequence of strings is by calling ''.join(sequence) .  To add floating-point values with extended precision,\nsee math.fsum() .  To concatenate a series of iterables, consider using itertools.chain() .\n\nChanged in version 3.8: The start parameter can be specified as a keyword argument.\n\nChanged in version 3.12: Summation of floats switched to an algorithm\nthat gives higher accuracy and better commutativity on most builds.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "sum(iterable, /, start=0)"
          },
          "metadata": {
            "signature": "sum(iterable, /, start=0)",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "vars()",
            "definition": "Return the __dict__ attribute for a module, class, instance,\nor any other object with a __dict__ attribute.\n\nObjects such as modules and instances have an updateable __dict__ attribute; however, other objects may have write restrictions on their __dict__ attributes (for example, classes use a types.MappingProxyType to prevent direct dictionary updates).\n\nWithout an argument, vars() acts like locals() .\n\nA TypeError exception is raised if an object is specified but\nit doesn\u2019t have a __dict__ attribute (for example, if\nits class defines the __slots__ attribute).\n\nChanged in version 3.13: The result of calling this function without an argument has been\nupdated as described for the locals() builtin.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "vars()"
          },
          "metadata": {
            "signature": "vars()",
            "has_examples": false
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "zip()",
            "definition": "Iterate over several iterables in parallel, producing tuples with an item\nfrom each one.\n\nExample:\n\nMore formally: zip() returns an iterator of tuples, where the i -th\ntuple contains the i -th element from each of the argument iterables.\n\nAnother way to think of zip() is that it turns rows into columns, and\ncolumns into rows.  This is similar to transposing a matrix .\n\nzip() is lazy: The elements won\u2019t be processed until the iterable is\niterated on, e.g. by a for loop or by wrapping in a list .\n\nOne thing to consider is that the iterables passed to zip() could have\ndifferent lengths; sometimes by design, and sometimes because of a bug in\nthe code that prepared these iterables.  Python offers three different\napproaches to dealing with this issue:\n\nBy default, zip() stops when the shortest iterable is exhausted.\nIt will ignore the remaining items in the longer iterables, cutting off\nthe result to the length of the shortest iterable: Copy >>> list ( zip ( range ( 3 ), [ 'fee' , 'fi' , 'fo' , 'fum' ])) [(0, 'fee'), (1, 'fi'), (2, 'fo')] zip() is often used in cases where the iterables are assumed to be\nof equal length.  In such cases, it\u2019s recommended to use the strict=True option. Its output is the same as regular zip() : Copy >>> list ( zip (( 'a' , 'b' , 'c' ), ( 1 , 2 , 3 ), strict = True )) [('a', 1), ('b', 2), ('c', 3)] Unlike the default behavior, it raises a ValueError if one iterable\nis exhausted before the others: Copy >>> for item in zip ( range ( 3 ), [ 'fee' , 'fi' , 'fo' , 'fum' ], strict = True ): ... print ( item ) ... (0, 'fee') (1, 'fi') (2, 'fo') Traceback (most recent call last): ... ValueError : zip() argument 2 is longer than argument 1 Without the strict=True argument, any bug that results in iterables of\ndifferent lengths will be silenced, possibly manifesting as a hard-to-find\nbug in another part of the program. Shorter iterables can be padded with a constant value to make all the\niterables have the same length.  This is done by itertools.zip_longest() .\n\nEdge cases: With a single iterable argument, zip() returns an\niterator of 1-tuples.  With no arguments, it returns an empty iterator.\n\nTips and tricks:\n\nThe left-to-right evaluation order of the iterables is guaranteed. This\nmakes possible an idiom for clustering a data series into n-length groups\nusing zip(*[iter(s)]*n, strict=True) .  This repeats the same iterator n times so that each output tuple has the result of n calls to the\niterator. This has the effect of dividing the input into n-length chunks. zip() in conjunction with the * operator can be used to unzip a\nlist: Copy >>> x = [ 1 , 2 , 3 ] >>> y = [ 4 , 5 , 6 ] >>> list ( zip ( x , y )) [(1, 4), (2, 5), (3, 6)] >>> x2 , y2 = zip ( * zip ( x , y )) >>> x == list ( x2 ) and y == list ( y2 ) True\n\nChanged in version 3.10: Added the strict argument.",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "zip(*iterables, strict=False)",
            "examples": [
              ">>>foriteminzip([1,2,3],['sugar','spice','everything nice']):...print(item)...(1, 'sugar')(2, 'spice')(3, 'everything nice')"
            ]
          },
          "metadata": {
            "signature": "zip(*iterables, strict=False)",
            "has_examples": true
          }
        },
        {
          "node_type": "term",
          "data": {
            "term": "import__()",
            "definition": "This function is invoked by the import statement.  It can be\nreplaced (by importing the builtins module and assigning to builtins.__import__ ) in order to change semantics of the import statement, but doing so is strongly discouraged as it\nis usually simpler to use import hooks (see PEP 302 ) to attain the same\ngoals and does not cause issues with code which assumes the default import\nimplementation is in use.  Direct use of __import__() is also\ndiscouraged in favor of importlib.import_module() .\n\nThe function imports the module name , potentially using the given globals and locals to determine how to interpret the name in a package context.\nThe fromlist gives the names of objects or submodules that should be\nimported from the module given by name .  The standard implementation does\nnot use its locals argument at all and uses its globals only to\ndetermine the package context of the import statement.\n\nlevel specifies whether to use absolute or relative imports. 0 (the\ndefault) means only perform absolute imports.  Positive values for level indicate the number of parent directories to search relative to the\ndirectory of the module calling __import__() (see PEP 328 for the\ndetails).\n\nWhen the name variable is of the form package.module , normally, the\ntop-level package (the name up till the first dot) is returned, not the\nmodule named by name .  However, when a non-empty fromlist argument is\ngiven, the module named by name is returned.\n\nFor example, the statement import spam results in bytecode resembling the\nfollowing code:\n\nThe statement import spam.ham results in this call:\n\nNote how __import__() returns the toplevel module here because this is\nthe object that is bound to a name by the import statement.\n\nOn the other hand, the statement from spam.ham import eggs, sausage as saus results in\n\nHere, the spam.ham module is returned from __import__() .  From this\nobject, the names to import are retrieved and assigned to their respective\nnames.\n\nIf you simply want to import a module (potentially within a package) by name,\nuse importlib.import_module() .\n\nChanged in version 3.3: Negative values for level are no longer supported (which also changes\nthe default value to 0).\n\nChanged in version 3.9: When the command line options -E or -I are being used,\nthe environment variable PYTHONCASEOK is now ignored.\n\nNotes:\n- Note This is an advanced function that is not needed in everyday Python\nprogramming, unlike importlib.import_module() .",
            "difficulty": "intermediate",
            "module": "built-in",
            "code_example": "__import__(name, globals=None, locals=None, fromlist=(), level=0)",
            "examples": [
              "spam=__import__('spam',globals(),locals(),[],0)",
              "spam=__import__('spam.ham',globals(),locals(),[],0)",
              "_temp=__import__('spam.ham',globals(),locals(),['eggs','sausage'],0)eggs=_temp.eggssaus=_temp.sausage"
            ]
          },
          "metadata": {
            "signature": "__import__(name, globals=None, locals=None, fromlist=(), level=0)",
            "has_examples": true
          }
        }
      ]
    }
  ]
}